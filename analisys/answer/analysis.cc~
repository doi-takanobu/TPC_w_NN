#include "analysis.hh"
#include "bethe.h"
#include "bethe_doi.h"
#include "kinema.h"
#include "kinema.hpp"
#include <iostream>
#include <cmath>
#include <TROOT.h>
#include <TTree.h>


Double_t getE(Double_t xv1,Double_t xv3,Double_t xs1,Double_t xs3)
{
  struct bethparm bp = {2,2,4,4,54.4,0,0,0};
  Double_t E=1.;
  Double_t dE=1.;
  Double_t dx;

  dx = sqrt((xs1-xv1)*(xs1-xv1)+(xs3-xv3)*(xs3-xv3));
  dx = dx*ch_to_cm;
  dx = dx*rho_He;// g/cm2
  while(1){
    bp.ene = E;
    bp.eloss = fnbeth(&bp,bp.ene);
    if(ethick(&bp)>dx){
      E = E-dE;
      dE = dE*0.1;
      if(dE < 0.0001){
	break;
      }
    }else{
      E = E+dE;
    }
  }
  
  return E;
}

Double_t getE(Double_t dx)
{
  struct bethparm bp = {2,2,4,4,54.4,0,0,0};
  const double de = 0.001;
  double E = 0.1;
  double range = 0;
  dx = dx*ch_to_cm;
  bp.ene = E;
  while(1){
    range += 1./bethe(2,4,1,2,4,E)*de/(rho_He);
//    range += 1./(2./31.*bethe(2,4,1,2,4,E)+
//		 24./31.*bethe(6,12,1,2,4,E)+
//		 5./31.*bethe(1,1,1,2,4,E))
//      *de/(0.95*rho_He+0.05*rho_C4H10);
//    std::cout << "range: " << range << std::endl;
//    std::cout << "E: " << E << std::endl;
    if(range>dx){
      E -= de;
      break;
    }
    E += de;
  }


//  dx = dx*ch_to_cm;
//  double a = 0.437067159459644;
//  double b = 1.70613516206486;
//  double c = 0.889015901255412-dx;
//
//  double E = (-b+sqrt(b*b-4*a*c))/(2*a);
  
  return E;
}

Double_t getthr(Double_t xv1,Double_t xv3,Double_t xs1,Double_t xs3)
{
  Double_t thr;
  Double_t dx;

  dx = sqrt((xs1-xv1)*(xs1-xv1)+(xs3-xv3)*(xs3-xv3));
  thr = acos((xs1-xv1)/dx);
  
  return thr;
}

Double_t getEx(Double_t E,Double_t thr,Double_t m1,Double_t m2,Double_t m3,Double_t m4)
{
  Double_t Ex;
  const Double_t K1 = 750;

  Ex = calcex4(thr,m1,m2,m3,m4,K1,E);
  
  return Ex;
}

TTree* calc_Ex(TTree *tin,const char *treenam)
{
  TTree *tree = new TTree(treenam,treenam);
  
  Double_t Ex;
  Double_t E;
  Double_t dx;
  Double_t thr;
  Double_t xv1,xv3,xs1,xs3;
  
//  tin->SetBranchAddress("xv1",&xv1);
//  tin->SetBranchAddress("xv3",&xv3);
//  tin->SetBranchAddress("xs1",&xs1);
//  tin->SetBranchAddress("xs3",&xs3);
  tin->SetBranchAddress("range",&dx);
  tin->SetBranchAddress("theta",&thr);
  tree->Branch("Ex",&Ex,"Ex/D");
  tree->Branch("E",&E,"E/D");
  tree->Branch("thr",&thr,"thr/D");

  kinema a;
  char *c = "10c";
  char *he = "4he";
  a.setparticles(c,he,he,c);
  const Int_t N = tin->GetEntries();

  for(Int_t ientry=0;ientry<N;ientry++){
    tin->GetEntry(ientry);
//    E = getE(xv1,xv3,xs1,xs3);
//    thr = getthr(xv1,xv3,xs1,xs3);
    thr = thr*M_PI/180.;
    E = getE(dx);
    Ex = getEx(E,thr,a.getmass(0),a.getmass(1),a.getmass(2),a.getmass(3));
    tree->Fill();
    if(ientry%100==0){
      std::cout << "ientry: " << ientry << std::endl;
    }
  }

  return tree;
}
